(1) How did you guarantee that each logical address is translated to the correct
    physical address?

    <need an answer here>

(2) How did implement the page table, physical memory, and TLB?

    Page table - page table is instantiated as a vector of pages.

    Physical memory - created physical address structure that includes full
    address, frame number, and offset. The physical memory itself is a vector
    of frame numbers, where each frame number correlates with a frame number
    in a struct. This effectively makes the vector an array of unique references
    to chunks of memory.

    TLB - a structure that contains a vector of TLB row objects. These TLB row
    objects include page number, frame number, and age.

(3) Does your program realistically and accurately simulate a virtual memory
    system?

    Absolutely. The code is designed to be as true to a virtual memory system
    as possible for us to achieve.

(4) Did you use the Java operators for bit-masking and bit-shifting?

    Yes, bit-shifting and bit-masking is performed with ">>" and "<<"
    operators.

(5) When a TLB miss occurs, how do you decide which entry to replace?

    The user will be able to select one of two methods to do this (both which
    are implemented): a first in first out system, where the first entry in
    would be the first to be replaced, or a least recently used system, where
    the entry being replaced will be the entry that was used the longest ago.



(1) How general is your solution?

    Our code is very general; we made our structures and functions with
    reusability in mind.

(2) How easy would it be to change parameters such as the size of the TLB?

    Very easy; since we were extremely conscious of reusability and
    maintainability throughout the design process, such changes do not
    require much source code manipulation.

(3) Does your program only load pages from the backing store when they are
    needed?

    Yes, the only time our program is designed to access backing_store is when
    it is absolutely necessary. Theoretically there are no redundant or
    unnecessary writes to or reads from backing_store based on our testing.

(4) Does your solution allow the physical address space to be smaller than the
    virtual address space?

    <need an answer here>




(1) Is your code elegant?

    The code definitely could be considered so. It is succinct, formatted well,
    and was made to be as general as we possibly could make it.

(2) How innovative is your solution? Did you try any ideas not suggested here
    (e.g. a choice of replacement policies for the TLB)? Innovative ideas that go
    beyond the requirements could receive extra credit.

    No; we tended to focus on ensuring functionality rather than innovation in
    effort to make sure everything worked well in good time.

(3) Did you document all outside sources?

    Yes; few were used, but where they are implemented they are credited.
